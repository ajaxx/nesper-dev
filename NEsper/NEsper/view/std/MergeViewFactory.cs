///////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2006-2017 Esper Team. All rights reserved.                           /
// http://esper.codehaus.org                                                          /
// ---------------------------------------------------------------------------------- /
// The software in this package is published under the terms of the GPL license       /
// a copy of which has been included with this distribution in the license.txt file.  /
///////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Linq;

using com.espertech.esper.client;
using com.espertech.esper.compat.collections;
using com.espertech.esper.core.context.util;
using com.espertech.esper.core.service;
using com.espertech.esper.epl.expression.core;
using com.espertech.esper.epl.expression;

namespace com.espertech.esper.view.std
{
    /// <summary>
    /// Factory for <seealso cref="MergeView"/> instances.
    /// </summary>
    public class MergeViewFactory
        : ViewFactory
        , MergeViewFactoryMarker
    {
        private IList<ExprNode> _viewParameters;
        private int _streamNumber;

        private ExprNode[] _criteriaExpressions;
        private EventType _eventType;
        private bool _removable = false;  // set to true when retain-age

        public void SetViewParameters(ViewFactoryContext viewFactoryContext, IList<ExprNode> expressionParameters)
        {
            _viewParameters = expressionParameters;
            _streamNumber = viewFactoryContext.StreamNum;
        }

        public void Attach(EventType parentEventType, StatementContext statementContext, ViewFactory optionalParentFactory, IList<ViewFactory> parentViewFactories)
        {
            // Find the group by view matching the merge view
            GroupByViewFactoryMarker groupByViewFactory = null;
            var unvalidated = _viewParameters.ToArray();
            foreach (var parentView in parentViewFactories)
            {
                if (!(parentView is GroupByViewFactoryMarker))
                {
                    continue;
                }
                var candidateGroupByView = (GroupByViewFactoryMarker)parentView;
                if (ExprNodeUtility.DeepEquals(candidateGroupByView.CriteriaExpressions, unvalidated, false))
                {
                    groupByViewFactory = candidateGroupByView;
                }
            }

            if (groupByViewFactory == null)
            {
                throw new ViewParameterException("Groupwin view for this merge view could not be found among parent views");
            }
            _criteriaExpressions = groupByViewFactory.CriteriaExpressions;
            _removable = groupByViewFactory.IsReclaimAged;

            // determine types of fields
            var fieldTypes = new Type[_criteriaExpressions.Length];
            for (var i = 0; i < fieldTypes.Length; i++)
            {
                fieldTypes[i] = _criteriaExpressions[i].ExprEvaluator.ReturnType;
            }

            // Determine the readonly event type that the merge view generates
            // This event type is ultimatly generated by AddPropertyValueView which is added to each view branch for each
            // group key.

            // If the parent event type contains the merge fields, we use the same event type
            var parentContainsMergeKeys = true;
            var fieldNames = new String[_criteriaExpressions.Length];
            for (var i = 0; i < _criteriaExpressions.Length; i++)
            {
                var name = ExprNodeUtility.ToExpressionStringMinPrecedenceSafe(_criteriaExpressions[i]);
                fieldNames[i] = name;

                try
                {
                    if (!(parentEventType.IsProperty(name)))
                    {
                        parentContainsMergeKeys = false;
                    }
                }
                catch (PropertyAccessException)
                {
                    // expected
                    parentContainsMergeKeys = false;
                }
            }

            // If the parent view contains the fields to group by, the event type after merging stays the same
            if (parentContainsMergeKeys)
            {
                _eventType = parentEventType;
            }
            else
            // If the parent event type does not contain the fields, such as when a statistics views is
            // grouped which simply provides a map of calculated values,
            // then we need to add in the merge field as an event property thus changing event types.
            {
                IDictionary<String, Object> additionalProps = new Dictionary<String, Object>();
                for (var i = 0; i < fieldNames.Length; i++)
                {
                    additionalProps.Put(fieldNames[i], fieldTypes[i]);
                }
                var outputEventTypeName = statementContext.StatementId + "_mergeview_" + _streamNumber;
                _eventType = statementContext.EventAdapterService.CreateAnonymousWrapperType(outputEventTypeName, parentEventType, additionalProps);
            }
        }

        public View MakeView(AgentInstanceViewFactoryChainContext agentInstanceViewFactoryContext)
        {
            return new MergeView(agentInstanceViewFactoryContext, _criteriaExpressions, _eventType, _removable);
        }

        public EventType EventType
        {
            get { return _eventType; }
        }

        public bool CanReuse(View view, AgentInstanceContext agentInstanceContext)
        {
            if (!(view is MergeView))
            {
                return false;
            }

            var myView = (MergeView)view;
            if (!ExprNodeUtility.DeepEquals(myView.GroupFieldNames, _criteriaExpressions, false))
            {
                return false;
            }
            return true;
        }

        public ExprNode[] CriteriaExpressions
        {
            get { return _criteriaExpressions; }
        }

        public string ViewName
        {
            get { return "Group-By-Merge"; }
        }
    }
}
